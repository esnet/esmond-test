#!/usr/bin/env python

import json
from multiprocessing import Process, Queue
from optparse import OptionParser
import os
import pprint
import random
import re
import requests
import sys
import time

from esmond.cassandra import AGG_TYPES

class fetchProcess(Process):
    def __init__(self, q, host, uri, delay, agg=None, cf=None):
        super(fetchProcess, self).__init__()
        self.q = q
        self.host = host
        self.uri = uri
        self.delay = delay
        self.agg = agg
        self.cf = cf
        self.duration = None
        self.text = None
        self.status = None
        self.url = None

    def return_name(self):
        s = '{0} in {1}'.format(self.name, self.duration)
        if self.status != 200:
            s += ' - got error {0}'.format(self.text)
        else:
            if len(self.text['data']):
                s += ' found data'
        return s

    def run(self):
        p = {}
        if self.agg: p['agg'] = self.agg
        if self.cf: p['cf'] = self.cf
        time.sleep(random.randint(0, self.delay))
        r = requests.get('http://{0}{1}'.format(self.host, self.uri), params=p)
        self.url = r.url
        self.duration = r.elapsed
        self.text = json.loads(r.text)
        self.status = r.status_code
        self.q.put((self.return_name(),self.url,self.text))

processes = []

def main():
    usage = '%prog [ -H hostname | -p # clients | -d randint delay | -a agg secs | -c cf  | -v or -vv ]'
    parser = OptionParser(usage=usage)
    parser.add_option('-H', '--hostname', metavar='HOST',
            type='string', dest='hostname', 
            help='Host running rest api (default=%default).', default='localhost')
    parser.add_option('-p', '--processes', metavar='PROCESSES',
            type='int', dest='processes', default=50,
            help='Number of client processes to launch (default=%default).')
    parser.add_option('-d', '--delay', metavar='DELAY',
            type='int', dest='delay', default=2,
            help='Second range generated by randint to introduce thread startup entropy (default=%default).')
    parser.add_option('-a', '--agg', metavar='AGG',
            type='int', dest='agg', default=None,
            help='Aggregation level in seconds.')
    parser.add_option('-c', '--cf', metavar='CF',
            type='string', dest='cf', default=None,
            help='Select consolidation function (min/max/average).')
    parser.add_option('-v', '--verbose',
            dest='verbose', action='count', default=False,
            help='Verbose output - -v, -vv, etc.')
    options, args = parser.parse_args()

    if options.cf and options.cf not in AGG_TYPES:
        print '--cf flag must be one of {0}'.format(AGG_TYPES)
        parser.print_help()
        return 1

    if options.cf and not options.agg:
        print 'must specify --agg arg when using --cf flag'
        parser.print_help()
        return 1

    pp = pprint.PrettyPrinter(indent=4)

    workers = []

    device_uris = []
    interface_uris = []
    traffic_uris = []

    r = requests.get('http://{0}/v1/device/'.format(options.hostname))

    if r.status_code == 200 and \
        r.headers['content-type'] == 'application/json':
        data = json.loads(r.text)
        for i in data:
            for ii in i['children']:
                if ii['name'] != 'interface':
                    continue
                device_uris.append(ii['uri'])

        for device in device_uris:
            r = requests.get('http://{0}/{1}/'.format(options.hostname, device))
            data = json.loads(r.text)
            for i in data['children']:
                interface_uris.append(i['resource_uri'])

        for interface in interface_uris:
            if len(traffic_uris) >= options.processes:
                break
            r = requests.get('http://{0}/{1}/'.format(options.hostname, interface))
            if r.status_code == 200:
                data = json.loads(r.text)
                if data['children']:
                    for c in data['children']:
                        if c['name'].endswith('in') or \
                            c['name'].endswith('out'):
                            traffic_uris.append(c['uri'])
            
        print 'gathered {0} traffic uris'.format(len(traffic_uris))
    else:
        print 'got bad response'

    for u in traffic_uris[0:options.processes]:
        p = fetchProcess(Queue(), options.hostname, u, options.delay, 
            options.agg, options.cf)
        processes.append(p)

    print 'launching {0} client processes...'.format(len(processes)),

    data_found = 0

    t = time.time()
    for p in processes:
        p.start()

    print 'go!'

    for p in processes:
        p.join()
        retval = p.q.get()
        if len(retval[2]['data']): data_found += 1
        resp = retval[0]
        if options.verbose >= 1:
            m = re.match('(http[\S]*device)(/[\S]+)*', retval[1])
            resp += ' ' + m.group(2)
        print resp
        if options.verbose >= 2 and len(retval[2]['data']):
            print '=' * 20
            pp.pprint(retval[2])
            print '=' * 20

    print 'fetched {0} endpoints in {1} seconds - {2} with data'.format(
            options.processes, 
            time.time() - t,
            data_found
        )

    sys.exit()

if __name__ == '__main__':
    main()