#!/usr/bin/env python

import json
from multiprocessing import Process, Queue
from optparse import OptionParser
import os
import pprint
import random
import re
import requests
import sys
import time

from esmond.cassandra import AGG_TYPES

class UrlContainer(object):
    def __init__(self, url):
        self.url = url

    def get_device(self):
        return self.url.split('/')[5]

    def get_shortened_request(self):
        return '/'.join(self.url.split('/')[5:])

class FetchProcess(Process):
    def __init__(self, q, host, uri, delay, agg=None, cf=None, last=None):
        super(FetchProcess, self).__init__()
        self.q = q
        self.host = host
        self.uri = uri
        self.delay = delay
        self.agg = agg
        self.cf = cf
        self.last = last
        self.duration = None
        self.text = None
        self.status = None
        self.url = None

    def generate_output(self):
        s = '{0} in {1}'.format(self.name, self.duration)
        if self.status != 200:
            if self.status == 404:
                s += ' - 404 {0}'.format(self.url.get_shortened_request())
            else:
                s += ' - got error {0}'.format(self.text)
        else:
            if self.text.strip(): self.text = json.loads(self.text)
            if len(self.text['data']):
                s += ' found data: {0}'.format(self.url.get_device())
        
        return (s, self.url, self.text)

    def run(self):
        p = {}
        if self.agg: p['agg'] = self.agg
        if self.cf: p['cf'] = self.cf
        if self.last: p['begin'] = time.time() - (self.last*60*60)
        time.sleep(random.randint(0, self.delay))
        r = requests.get('http://{0}{1}'.format(self.host, self.uri), params=p)
        self.url = UrlContainer(r.url)
        self.duration = r.elapsed
        self.status = r.status_code
        self.text = r.text
        self.q.put(self.generate_output())

class RequestGenerator(object):
    def __init__(self, hostname, process_limit, intercloud, randomize):
        self.hostname = hostname
        self.process_limit = process_limit
        self.intercloud = intercloud
        self.randomize = randomize

        self.device_uris = []
        self.interface_uris = []
        self.endpoint_uris = []

    def _generate_devices(self):
        r = requests.get('http://{0}/v1/device/?limit=0'.format(self.hostname))

        if r.status_code == 200 and \
            r.headers['content-type'] == 'application/json':
            data = json.loads(r.text)
            for i in data:
                if not i['name'].endswith('-cr5') and self.intercloud:
                    continue
                for ii in i['children']:
                    if ii['name'] != 'interface':
                        continue
                    self.device_uris.append(ii['uri'])

        if self.randomize: 
            self.device_uris = random.sample(self.device_uris, len(self.device_uris))

        # return self.device_uris

    def _generate_interfaces(self):
        for device in self.device_uris:
            if len(self.interface_uris) > self.process_limit:
                break
            r = requests.get('http://{0}/{1}/'.format(self.hostname, device))
            data = json.loads(r.text)
            for i in data['children']:
                self.interface_uris.append(i['resource_uri'])

        if self.randomize:
            self.interface_uris = random.sample(self.interface_uris, len(self.interface_uris))

        # return self.interface_uris

    def _generate_endpoints(self):
        for interface in self.interface_uris:
            if len(self.endpoint_uris) >= self.process_limit:
                break
            r = requests.get('http://{0}/{1}/'.format(self.hostname, interface))
            if r.status_code == 200:
                data = json.loads(r.text)
                if data['children']:
                    for c in data['children']:
                        if c['name'].endswith('in') or \
                            c['name'].endswith('out'):
                            self.endpoint_uris.append(c['uri'])

        # return self.endpoint_uris[0:self.process_limit]

    def get_endpoint_list(self):
        self._generate_devices()
        self._generate_interfaces()
        self._generate_endpoints()

        return self.endpoint_uris[0:self.process_limit]


processes = []

def main():
    usage = '%prog [ -H hostname | -p # clients | -d randint delay | -a agg secs | -c cf  | -v or -vv ]'
    parser = OptionParser(usage=usage)
    parser.add_option('-H', '--hostname', metavar='HOST',
            type='string', dest='hostname', 
            help='Host running rest api (default=%default).', default='localhost')
    parser.add_option('-p', '--processes', metavar='PROCESSES',
            type='int', dest='processes', default=50,
            help='Number of client processes to launch (default=%default).')
    parser.add_option('-d', '--delay', metavar='DELAY',
            type='int', dest='delay', default=2,
            help='Second range generated by randint to introduce thread startup entropy (default=%default).')
    parser.add_option('-a', '--agg', metavar='AGG',
            type='int', dest='agg', default=None,
            help='Aggregation level in seconds.')
    parser.add_option('-c', '--cf', metavar='CF',
            type='string', dest='cf', default=None,
            help='Select consolidation function (min/max/average).')
    parser.add_option('-l', '--last', metavar='LAST',
            type='int', dest='last', default=0,
            help='Set time range to last n hours. If unset, api defaults to last hour.')
    parser.add_option('-i', '--intercloud',
            dest='intercloud', action='store_true', default=False,
            help='Filter to intercloud devices (ending in -cr5).')
    parser.add_option('-r', '--randomize',
            dest='randomize', action='store_true', default=False,
            help='Randomize endpoint list to get heterogenous results.')
    parser.add_option('-v', '--verbose',
            dest='verbose', action='count', default=False,
            help='Verbose output - -v, -vv, etc.')
    options, args = parser.parse_args()

    if options.cf and options.cf not in AGG_TYPES:
        print '--cf flag must be one of {0}'.format(AGG_TYPES)
        parser.print_help()
        return 1

    if options.cf and not options.agg:
        print 'must specify --agg arg when using --cf flag'
        parser.print_help()
        return 1

    pp = pprint.PrettyPrinter(indent=4)

    endpoint_uris = []

    rgen = RequestGenerator(options.hostname, options.processes,
        options.intercloud, options.randomize)

    endpoint_uris = rgen.get_endpoint_list()
    
    for u in endpoint_uris:
        p = FetchProcess(Queue(), options.hostname, u, options.delay, 
            options.agg, options.cf, options.last)
        processes.append(p)

    print 'launching {0} client processes...'.format(len(endpoint_uris)),

    data_found = 0

    t = time.time()
    for p in processes:
        p.start()

    print 'go!'

    for p in processes:
        p.join()
        retval = p.q.get()
        if retval[0].find('got error') > -1:
            print retval[0], retval[1]
            continue
        if retval[2] and len(retval[2]['data']): data_found += 1
        resp = retval[0]
        if options.verbose >= 1:
            resp += ' ' + retval[1].get_shortened_request()
        print resp
        if options.verbose >= 2 and len(retval[2]['data']):
            print '=' * 20
            pp.pprint(retval[2])
            print '=' * 20

    print 'fetched {0} endpoints in {1} seconds - {2} with data'.format(
            len(endpoint_uris), 
            time.time() - t,
            data_found
        )

    sys.exit()

if __name__ == '__main__':
    main()