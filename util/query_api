#!/usr/bin/env python

import json
from multiprocessing import Process, Queue
from optparse import OptionParser
import os
import random
import requests
import sys
import time

class fetchProcess(Process):
    def __init__(self, q, host, uri, delay):
        super(fetchProcess, self).__init__()
        self.q = q
        self.host = host
        self.uri = uri
        self.delay = delay
        self.duration = None
        self.text = None
        self.status = None

    def return_name(self):
        s = '{0} - {1} in {2}'.format(
            self.name, self.uri, 
            self.duration)
        if self.status != 200:
            s += ' - got error {0}'.format(self.text)
        return s

    def run(self):
        time.sleep(random.randint(0, self.delay))
        r = requests.get('http://{0}/{1}'.format(self.host, self.uri))
        self.duration = r.elapsed
        self.text = r.text
        self.status = r.status_code
        self.q.put(self.return_name())

processes = []

def main():
    usage = '%prog [ -H hostname | -t number of threads | -d randint delay entropy ]'
    parser = OptionParser(usage=usage)
    parser.add_option('-H', '--hostname', metavar='HOST',
            type='string', dest='hostname', 
            help='Host running rest api (default=%default).', default='localhost')
    parser.add_option('-t', '--threads', metavar='THREADS',
            type='int', dest='threads', default=50,
            help='Number of client threads to launch (default=%default).')
    parser.add_option('-d', '--delay', metavar='DELAY',
            type='int', dest='delay', default=2,
            help='Second range generated by randint to introduce thread startup entropy (default=%default).')
    options, args = parser.parse_args()

    workers = []

    device_uris = []
    interface_uris = []
    traffic_uris = []

    r = requests.get('http://{0}/v1/device/'.format(options.hostname))

    if r.status_code == 200 and \
        r.headers['content-type'] == 'application/json':
        data = json.loads(r.text)
        for i in data:
            for ii in i['children']:
                if ii['name'] != 'interface':
                    continue
                device_uris.append(ii['uri'])

        for device in device_uris:
            r = requests.get('http://{0}/{1}/'.format(options.hostname, device))
            data = json.loads(r.text)
            for i in data['children']:
                interface_uris.append(i['resource_uri'])

        for interface in interface_uris:
            if len(traffic_uris) >= options.threads:
                break
            r = requests.get('http://{0}/{1}/'.format(options.hostname, interface))
            if r.status_code == 200:
                data = json.loads(r.text)
                if data['children']:
                    for c in data['children']:
                        if c['name'] == 'in' or c['name'] == 'out':
                            traffic_uris.append(c['uri'])
            
        print 'gathered {0} traffic uris'.format(len(traffic_uris))
    else:
        print 'got bad response'

    for u in traffic_uris[0:options.threads]:
        p = fetchProcess(Queue(), options.hostname, u, options.delay)
        processes.append(p)

    print 'launching {0} client processes'.format(len(processes))

    t = time.time()
    for p in processes:
        p.start()

    for p in processes:
        p.join()
        print p.q.get()

    print 'fetched {0} endpoints in {1} seconds'.format(options.threads, time.time() - t)

    sys.exit()

if __name__ == '__main__':
    main()