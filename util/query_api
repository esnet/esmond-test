#!/usr/bin/env python

import json
from multiprocessing import Process, Queue
from optparse import OptionParser
import os
import pprint
import random
import re
import requests
import sys
import time

from esmond.cassandra import AGG_TYPES

class fetchProcess(Process):
    def __init__(self, q, host, uri, delay, agg=None, cf=None, last=None):
        super(fetchProcess, self).__init__()
        self.q = q
        self.host = host
        self.uri = uri
        self.delay = delay
        self.agg = agg
        self.cf = cf
        self.last = last
        self.duration = None
        self.text = None
        self.status = None
        self.url = None

    def return_name(self):
        s = '{0} in {1}'.format(self.name, self.duration)
        if self.status != 200:
            s += ' - got error {0}'.format(self.text)
        else:
            if len(self.text['data']):
                m = re.match('/v1/device/([\S]*)/interface', self.uri)
                s += ' found data: {0}'.format(m.group(1))
        return s

    def run(self):
        p = {}
        if self.agg: p['agg'] = self.agg
        if self.cf: p['cf'] = self.cf
        if self.last: p['begin'] = time.time() - (self.last*60*60)
        time.sleep(random.randint(0, self.delay))
        r = requests.get('http://{0}{1}'.format(self.host, self.uri), params=p)
        self.url = r.url
        self.duration = r.elapsed
        self.text = json.loads(r.text)
        self.status = r.status_code
        self.q.put((self.return_name(),self.url,self.text))

processes = []

def main():
    usage = '%prog [ -H hostname | -p # clients | -d randint delay | -a agg secs | -c cf  | -v or -vv ]'
    parser = OptionParser(usage=usage)
    parser.add_option('-H', '--hostname', metavar='HOST',
            type='string', dest='hostname', 
            help='Host running rest api (default=%default).', default='localhost')
    parser.add_option('-p', '--processes', metavar='PROCESSES',
            type='int', dest='processes', default=50,
            help='Number of client processes to launch (default=%default).')
    parser.add_option('-d', '--delay', metavar='DELAY',
            type='int', dest='delay', default=2,
            help='Second range generated by randint to introduce thread startup entropy (default=%default).')
    parser.add_option('-a', '--agg', metavar='AGG',
            type='int', dest='agg', default=None,
            help='Aggregation level in seconds.')
    parser.add_option('-c', '--cf', metavar='CF',
            type='string', dest='cf', default=None,
            help='Select consolidation function (min/max/average).')
    parser.add_option('-l', '--last', metavar='LAST',
            type='int', dest='last', default=0,
            help='Set time range to last n hours. If unset, api defaults to last hour.')
    parser.add_option('-f', '--filter',
            dest='filter', action='store_true', default=False,
            help='Filter to theoreticaly high traffic devices (ending in -cr5).')
    parser.add_option('-v', '--verbose',
            dest='verbose', action='count', default=False,
            help='Verbose output - -v, -vv, etc.')
    options, args = parser.parse_args()

    if options.cf and options.cf not in AGG_TYPES:
        print '--cf flag must be one of {0}'.format(AGG_TYPES)
        parser.print_help()
        return 1

    if options.cf and not options.agg:
        print 'must specify --agg arg when using --cf flag'
        parser.print_help()
        return 1

    pp = pprint.PrettyPrinter(indent=4)

    workers = []

    device_uris = []
    interface_uris = []
    traffic_uris = []

    r = requests.get('http://{0}/v1/device/?limit=0'.format(options.hostname))

    if r.status_code == 200 and \
        r.headers['content-type'] == 'application/json':
        data = json.loads(r.text)
        for i in data:
            if not i['name'].endswith('-cr5') and options.filter:
                # continue
                pass
            for ii in i['children']:
                if ii['name'] != 'interface':
                    continue
                device_uris.append(ii['uri'])

        for device in random.sample(device_uris, len(device_uris)):
            if len(interface_uris) > options.processes:
                break
            r = requests.get('http://{0}/{1}/'.format(options.hostname, device))
            data = json.loads(r.text)
            for i in data['children']:
                interface_uris.append(i['resource_uri'])

        for interface in random.sample(interface_uris, len(interface_uris)):
            if len(traffic_uris) >= options.processes:
                break
            r = requests.get('http://{0}/{1}/'.format(options.hostname, interface))
            if r.status_code == 200:
                data = json.loads(r.text)
                if data['children']:
                    for c in data['children']:
                        if c['name'].endswith('in') or \
                            c['name'].endswith('out'):
                            traffic_uris.append(c['uri'])
            
        print 'gathered {0} traffic uris'.format(len(traffic_uris))
    else:
        print 'got bad response'
    
    for u in traffic_uris[0:options.processes]:
        p = fetchProcess(Queue(), options.hostname, u, options.delay, 
            options.agg, options.cf, options.last)
        processes.append(p)

    print 'launching {0} client processes...'.format(len(processes)),

    data_found = 0

    t = time.time()
    for p in processes:
        p.start()

    print 'go!'

    for p in processes:
        p.join()
        retval = p.q.get()
        if retval[0].find('got error') > -1:
            print retval[0], retval[1]
            continue
        if len(retval[2]['data']): data_found += 1
        resp = retval[0]
        if options.verbose >= 1:
            m = re.match('(http[\S]*device)(/[\S]+)*', retval[1])
            resp += ' ' + m.group(2)
        print resp
        if options.verbose >= 2 and len(retval[2]['data']):
            print '=' * 20
            pp.pprint(retval[2])
            print '=' * 20

    print 'fetched {0} endpoints in {1} seconds - {2} with data'.format(
            options.processes, 
            time.time() - t,
            data_found
        )

    sys.exit()

if __name__ == '__main__':
    main()