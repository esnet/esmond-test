#!/usr/bin/env python

"""
Load json files of esmond data into cassandra in a fashion similar to test framework.

Should be run from directory containing the esmond.db testing metadata file.
"""
import datetime
import json
import os
import os.path
import shutil
import sys
import time

from optparse import OptionParser

from django.conf import settings

import tsdb
from tsdb.row import ROW_VALID

from esmond.api.tests import TestPersistQueue
from esmond.config import get_config, get_config_path
from esmond.persist import CassandraPollPersister, TSDBPollPersister
from esmond.cassandra import CASSANDRA_DB, RawData
from pycassa.columnfamily import ColumnFamily

usage = '%prog -f FILE'
desc = ' '.join(__doc__.split())
parser = OptionParser(usage=usage, description=desc)
parser.add_option('-f', '--infile', dest='filename', metavar='FILE', default="",
                  help='Read FILE containing esmond json data.')
parser.add_option("-t", "--test", action="store_true", dest="test", default=False,
                  help="Execute tsdb comparison test after loading.")
options, args = parser.parse_args()

if not options.filename:
    parser.error('A filename is required')

file_path = os.path.normpath(options.filename)

if not os.path.exists(file_path):
    print file_path, 'does not exist - exiting.'
    sys.exit()
    
db_path = os.path.normpath(os.path.join(os.getcwd(), 'esmond.db'))

if not os.path.exists(db_path):
    parser.error('Run from directory containing testing esmond.db')
    
test_data = json.loads(open(file_path).read())

print 'Loaded:', test_data[0]['device_name'], test_data[0]['oidset_name'], 'etc...'

config = get_config(get_config_path())

if not config.db_clear_on_testing and os.environ.get("ESMOND_TESTING", False):
    print """
    The db_clear_on_testing config value is set to False.  Be aware that loading 
    the same data multiple times in this mode will generate incorrect base
    rate values.
    """

q = TestPersistQueue(test_data)
p = CassandraPollPersister(config, "test", persistq=q)
p.run()
p.db.flush()
p.db.close()
p.db.stats.report('all')

if options.test:
    print 'Executing tsdb test.'
    
    # Read in the test json file
    test_data = json.loads(open(file_path).read())
    
    router = test_data[0]['device_name']
    
    tsdb_path = os.path.join(settings.ESMOND_ROOT, "tsdb-data", router)

    # Prune old tsdb data if need be.
    if os.path.exists(tsdb_path):
        shutil.rmtree(tsdb_path, ignore_errors=True)
        pass

    # Run the data through the persister.
    print 'Starting tsdb load'
    t = time.time()
    q = TestPersistQueue(test_data)
    p = TSDBPollPersister(config, "test", persistq=q)
    p.run()
    print 'Done in', time.time() - t, 'seconds'

    # Execute one-to-one test of values written to TSDB and the
    # associated values written to Cassandra.

    path_levels = []

    # Use os.walk to generate arrays of oids, oidsets and paths
    # by walking the tsdb data/directory hierarchy.
    for (path, dirs, files) in os.walk(tsdb_path):
        if dirs[0] == 'TSDBAggregates':
            break
        path_levels.append(dirs)
    
    oidsets = path_levels[0]
    oids    = path_levels[1]
    paths   = path_levels[2]

    full_paths = {}
    
    # Iterate through the lists generated by the walk() and generate
    # all the tsdb device/oidset/oid/path/TSDBAggregates/30 paths.
    for oidset in oidsets:
        for oid in oids:
            for path in paths:
                full_path = '%s/%s/%s/%s/TSDBAggregates/30'  % \
                    (router, oidset, oid, path)
                if not full_paths.has_key(full_path):
                    full_paths[full_path] = 1
                
    ts_db = tsdb.TSDB(config.tsdb_root)
    db = CASSANDRA_DB(config)

    rates = ColumnFamily(db.pool, db.rate_cf)

    count_bad = 0
    tsdb_aggs = 0

    print 'Starting tsdb one to one scan'
    time.sleep(8)
    t = time.time()

    # Iterate through the generated dict of tsdb aggregate paths.
    for p in full_paths.keys():
        print '* Checking', p
        v = ts_db.get_var(p)
        # Split the path back into bits.
        device,oidset,oid,path,tmp1,tmp2 = p.split('/')
        # Iterate through the values at a certain node with the 
        # tsdb select.
        for d in v.select():
            tsdb_aggs += 1
            # Generate the corresponding cassandra row key.
            key = '%s%s%s%s%s%s%s%s%s'  % \
                (device, RawData._key_delimiter,
                path, RawData._key_delimiter,
                oid, RawData._key_delimiter,
                tmp2, RawData._key_delimiter,
                datetime.datetime.utcfromtimestamp(d.timestamp).year)
            # Get the corresponding cassandra value at the timestamp
            # of the tsdb data.
            val = rates.get(key, [d.timestamp])[d.timestamp]
            # Test the values.
            if d.flags != ROW_VALID:
                assert val['is_valid'] == 0
            else:
                assert val['val'] == d.delta
                assert val['is_valid'] > 0

    print 'Done in', time.time() - t, 'seconds'
    db.close()
